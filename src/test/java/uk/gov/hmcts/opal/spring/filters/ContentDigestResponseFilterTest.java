package uk.gov.hmcts.opal.spring.filters;

import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

import jakarta.servlet.FilterChain;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.util.ContentCachingResponseWrapper;
import uk.gov.hmcts.opal.spring.properties.ContentDigestProperties;

@ExtendWith(MockitoExtension.class)
class ContentDigestResponseFilterTest {

    @Mock
    ContentDigestProperties contentDigestProperties;

    @Mock
    ContentDigestProperties.Response contentDigestResponse;

    @InjectMocks
    @Spy
    ContentDigestResponseFilter contentDigestResponseFilter;

    @BeforeEach
    void setUp() {
        when(contentDigestProperties.getResponse()).thenReturn(contentDigestResponse);
    }


    @Nested
    @DisplayName("doFilterInternal")
    class DoFilterInternal {

        private void setupAutoGenerated(boolean isAutoGenerated) {
            when(contentDigestResponse.isAutoGenerated()).thenReturn(isAutoGenerated);
        }

        @DisplayName("Should skip when config has the response is auto generated disabled")
        @Test
        void shouldSkipWhenConfigHasTheResponseIsAutoGeneratedDisabled() {
            setupAutoGenerated(false);
            HttpServletRequest request = mock(HttpServletRequest.class);
            HttpServletResponse response = mock(HttpServletResponse.class);
            FilterChain chain = mock(FilterChain.class);

            try {
                contentDigestResponseFilter.doFilterInternal(request, response, chain);
                verify(chain).doFilter(request, response);
                verifyNoMoreInteractions(chain);
                verifyNoInteractions(request, response);
            } catch (Exception e) {
                fail("Exception should not be thrown", e);
            }
        }

        @DisplayName("Should skip if response has no body")
        @Test
        void shouldSkipIfResponseHasNoBody() {
            setupAutoGenerated(true);
            HttpServletRequest request = mock(HttpServletRequest.class);
            HttpServletResponse response = mock(HttpServletResponse.class);
            FilterChain chain = mock(FilterChain.class);
            ContentCachingResponseWrapper contentCachingResponseWrapper = mock(ContentCachingResponseWrapper.class);

            doReturn(contentCachingResponseWrapper).when(contentDigestResponseFilter).wrapResponse(response);
            when(contentCachingResponseWrapper.getContentAsByteArray()).thenReturn(new byte[0]);

            try {
                contentDigestResponseFilter.doFilterInternal(request, response, chain);
                verify(chain).doFilter(request, contentCachingResponseWrapper);
                verify(contentCachingResponseWrapper).copyBodyToResponse();

                verifyNoMoreInteractions(chain, contentCachingResponseWrapper);
                verifyNoInteractions(request, response);
            } catch (Exception e) {
                fail("Exception should not be thrown", e);
            }
        }

        @DisplayName("Should skip if already has Content-Digest header")
        @Test
        void shouldSkipIfAlreadyHasContentDigestHeader() {
            setupAutoGenerated(true);
            HttpServletRequest request = mock(HttpServletRequest.class);
            HttpServletResponse response = mock(HttpServletResponse.class);
            FilterChain chain = mock(FilterChain.class);
            ContentCachingResponseWrapper contentCachingResponseWrapper = mock(ContentCachingResponseWrapper.class);

            doReturn(contentCachingResponseWrapper).when(contentDigestResponseFilter).wrapResponse(response);
            doReturn("some-response-data".getBytes()).when(contentCachingResponseWrapper).getContentAsByteArray();
            doReturn("existing-digest-header").when(contentCachingResponseWrapper).getHeader("Content-Digest");

            try {
                contentDigestResponseFilter.doFilterInternal(request, response, chain);
                verify(chain).doFilter(request, contentCachingResponseWrapper);
                verify(contentCachingResponseWrapper).copyBodyToResponse();
                verifyNoMoreInteractions(chain, contentCachingResponseWrapper);
                verifyNoInteractions(request, response);
            } catch (Exception e) {
                fail("Exception should not be thrown", e);
            }
        }

        @DisplayName("Should add Content-Digest header when response has body does not already have one "
            + "and auto generated is enabled")
        @Test
        void shouldAddContentDigestHeaderWhenResponseHasBody() {
            setupAutoGenerated(true);
            HttpServletRequest request = mock(HttpServletRequest.class);
            HttpServletResponse response = mock(HttpServletResponse.class);
            FilterChain chain = mock(FilterChain.class);
            ContentCachingResponseWrapper contentCachingResponseWrapper = mock(ContentCachingResponseWrapper.class);

            doReturn(contentCachingResponseWrapper).when(contentDigestResponseFilter).wrapResponse(response);
            doReturn("some-response-data".getBytes()).when(contentCachingResponseWrapper).getContentAsByteArray();
            doReturn(null).when(contentCachingResponseWrapper).getHeader("Content-Digest");
            doReturn("SHA-256").when(contentDigestResponse).getAlgorithm();
            try {
                contentDigestResponseFilter.doFilterInternal(request, response, chain);
                verify(chain).doFilter(request, contentCachingResponseWrapper);
                verify(contentCachingResponseWrapper).copyBodyToResponse();
                verify(contentCachingResponseWrapper).setHeader("Content-Digest",
                    "sha-256=:+7BlgJWpPCi1NrFcspFwISGvTo7adL/I1aWaWEuQUn8=:");
                verifyNoMoreInteractions(chain, contentCachingResponseWrapper);
                verifyNoInteractions(request, response);
            } catch (Exception e) {
                fail("Exception should not be thrown", e);
            }
        }
    }
}
